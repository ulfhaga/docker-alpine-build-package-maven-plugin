Revert 7fdd0d6ef2d3 due build error
This laos reverts a fix for CVE-2019-2745
--- openjdk.orig/jdk/src/share/classes/sun/security/ec/ECDSAOperations.java	2019-07-14 02:30:40.000000000 +0200
+++ openjdk/jdk/src/share/classes/sun/security/ec/ECDSAOperations.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,206 +0,0 @@
-/*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.security.ec;
-
-import sun.security.ec.point.*;
-import sun.security.util.ArrayUtil;
-import sun.security.util.Function;
-import sun.security.util.Optional;
-import sun.security.util.math.*;
-import static sun.security.ec.ECOperations.IntermediateValueException;
-
-import java.security.ProviderException;
-import java.security.spec.*;
-
-public class ECDSAOperations {
-
-    public static class Seed {
-        private final byte[] seedValue;
-
-        public Seed(byte[] seedValue) {
-            this.seedValue = seedValue;
-        }
-
-        public byte[] getSeedValue() {
-            return seedValue;
-        }
-    }
-
-    public static class Nonce {
-        private final byte[] nonceValue;
-
-        public Nonce(byte[] nonceValue) {
-            this.nonceValue = nonceValue;
-        }
-
-        public byte[] getNonceValue() {
-            return nonceValue;
-        }
-    }
-
-    private final ECOperations ecOps;
-    private final AffinePoint basePoint;
-
-    public ECDSAOperations(ECOperations ecOps, ECPoint basePoint) {
-        this.ecOps = ecOps;
-        this.basePoint = toAffinePoint(basePoint, ecOps.getField());
-    }
-
-    public ECOperations getEcOperations() {
-        return ecOps;
-    }
-
-    public AffinePoint basePointMultiply(byte[] scalar) {
-        return ecOps.multiply(basePoint, scalar).asAffine();
-    }
-
-    public static AffinePoint toAffinePoint(ECPoint point,
-        IntegerFieldModuloP field) {
-
-        ImmutableIntegerModuloP affineX = field.getElement(point.getAffineX());
-        ImmutableIntegerModuloP affineY = field.getElement(point.getAffineY());
-        return new AffinePoint(affineX, affineY);
-    }
-
-    public static
-    Optional<ECDSAOperations> forParameters(final ECParameterSpec ecParams) {
-        Optional<ECOperations> curveOps =
-            ECOperations.forParameters(ecParams);
-        return curveOps.map(new Function<ECOperations, ECDSAOperations>() {
-            @Override
-            public ECDSAOperations apply(ECOperations ops) {
-                return new ECDSAOperations(ops, ecParams.getGenerator());
-            }
-        });
-    }
-
-    /**
-     *
-     * Sign a digest using the provided private key and seed.
-     * IMPORTANT: The private key is a scalar represented using a
-     * little-endian byte array. This is backwards from the conventional
-     * representation in ECDSA. The routines that produce and consume this
-     * value uses little-endian, so this deviation from convention removes
-     * the requirement to swap the byte order. The returned signature is in
-     * the conventional byte order.
-     *
-     * @param privateKey the private key scalar as a little-endian byte array
-     * @param digest the digest to be signed
-     * @param seed the seed that will be used to produce the nonce. This object
-     *             should contain an array that is at least 64 bits longer than
-     *             the number of bits required to represent the group order.
-     * @return the ECDSA signature value
-     * @throws IntermediateValueException if the signature cannot be produced
-     *      due to an unacceptable intermediate or final value. If this
-     *      exception is thrown, then the caller should discard the nonnce and
-     *      try again with an entirely new nonce value.
-     */
-    public byte[] signDigest(byte[] privateKey, byte[] digest, Seed seed)
-        throws IntermediateValueException {
-
-        byte[] nonceArr = ecOps.seedToScalar(seed.getSeedValue());
-
-        Nonce nonce = new Nonce(nonceArr);
-        return signDigest(privateKey, digest, nonce);
-    }
-
-    /**
-     *
-     * Sign a digest using the provided private key and nonce.
-     * IMPORTANT: The private key and nonce are scalars represented by a
-     * little-endian byte array. This is backwards from the conventional
-     * representation in ECDSA. The routines that produce and consume these
-     * values use little-endian, so this deviation from convention removes
-     * the requirement to swap the byte order. The returned signature is in
-     * the conventional byte order.
-     *
-     * @param privateKey the private key scalar as a little-endian byte array
-     * @param digest the digest to be signed
-     * @param nonce the nonce object containing a little-endian scalar value.
-     * @return the ECDSA signature value
-     * @throws IntermediateValueException if the signature cannot be produced
-     *      due to an unacceptable intermediate or final value. If this
-     *      exception is thrown, then the caller should discard the nonnce and
-     *      try again with an entirely new nonce value.
-     */
-    public byte[] signDigest(byte[] privateKey, byte[] digest, Nonce nonce)
-        throws IntermediateValueException {
-
-        IntegerFieldModuloP orderField = ecOps.getOrderField();
-        int orderBits = orderField.getSize().bitLength();
-        if (orderBits % 8 != 0 && orderBits < digest.length * 8) {
-            // This implementation does not support truncating digests to
-            // a length that is not a multiple of 8.
-            throw new ProviderException("Invalid digest length");
-        }
-
-        byte[] k = nonce.getNonceValue();
-        // check nonce length
-        int length = (orderField.getSize().bitLength() + 7) / 8;
-        if (k.length != length) {
-            throw new ProviderException("Incorrect nonce length");
-        }
-
-        MutablePoint R = ecOps.multiply(basePoint, k);
-        IntegerModuloP r = R.asAffine().getX();
-        // put r into the correct field by fully reducing to an array
-        byte[] temp = new byte[length];
-        r.asByteArray(temp);
-        r = orderField.getElement(temp);
-        // store r in result
-        r.asByteArray(temp);
-        byte[] result = new byte[2 * length];
-        ArrayUtil.reverse(temp);
-        System.arraycopy(temp, 0, result, 0, length);
-        // compare r to 0
-        if (ECOperations.allZero(temp)) {
-            throw new IntermediateValueException();
-        }
-
-        IntegerModuloP dU = orderField.getElement(privateKey);
-        int lengthE = Math.min(length, digest.length);
-        byte[] E = new byte[lengthE];
-        System.arraycopy(digest, 0, E, 0, lengthE);
-        ArrayUtil.reverse(E);
-        IntegerModuloP e = orderField.getElement(E);
-        IntegerModuloP kElem = orderField.getElement(k);
-        IntegerModuloP kInv = kElem.multiplicativeInverse();
-        MutableIntegerModuloP s = r.mutable();
-        s.setProduct(dU).setSum(e).setProduct(kInv);
-        // store s in result
-        s.asByteArray(temp);
-        ArrayUtil.reverse(temp);
-        System.arraycopy(temp, 0, result, length, length);
-        // compare s to 0
-        if (ECOperations.allZero(temp)) {
-            throw new IntermediateValueException();
-        }
-
-        return result;
-
-    }
-
-}
--- openjdk.orig/jdk/src/share/classes/sun/security/ec/ECOperations.java	2019-07-14 02:30:40.000000000 +0200
+++ openjdk/jdk/src/share/classes/sun/security/ec/ECOperations.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,499 +0,0 @@
-/*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.security.ec;
-
-import sun.security.ec.point.*;
-import sun.security.util.Optional;
-import sun.security.util.math.*;
-import sun.security.util.math.intpoly.*;
-
-import java.math.BigInteger;
-import java.security.ProviderException;
-import java.security.spec.ECFieldFp;
-import java.security.spec.ECParameterSpec;
-import java.security.spec.EllipticCurve;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-
-/*
- * Elliptic curve point arithmetic for prime-order curves where a=-3.
- * Formulas are derived from "Complete addition formulas for prime order
- * elliptic curves" by Renes, Costello, and Batina.
- */
-
-public class ECOperations {
-
-    /*
-     * An exception indicating a problem with an intermediate value produced
-     * by some part of the computation. For example, the signing operation
-     * will throw this exception to indicate that the r or s value is 0, and
-     * that the signing operation should be tried again with a different nonce.
-     */
-    static class IntermediateValueException extends Exception {
-        private static final long serialVersionUID = 1;
-    }
-
-    static final Map<BigInteger, IntegerFieldModuloP> fields;
-
-    static final Map<BigInteger, IntegerFieldModuloP> orderFields;
-
-    static {
-        Map<BigInteger, IntegerFieldModuloP> map = new HashMap<>();
-        map.put(IntegerPolynomialP256.MODULUS, new IntegerPolynomialP256());
-        map.put(IntegerPolynomialP384.MODULUS, new IntegerPolynomialP384());
-        map.put(IntegerPolynomialP521.MODULUS, new IntegerPolynomialP521());
-        fields = Collections.unmodifiableMap(map);
-        map = new HashMap<>();
-        map.put(P256OrderField.MODULUS, new P256OrderField());
-        map.put(P384OrderField.MODULUS, new P384OrderField());
-        map.put(P521OrderField.MODULUS, new P521OrderField());
-        orderFields = Collections.unmodifiableMap(map);
-    }
-
-    public static Optional<ECOperations> forParameters(ECParameterSpec params) {
-
-        EllipticCurve curve = params.getCurve();
-        if (!(curve.getField() instanceof ECFieldFp)) {
-            return Optional.empty();
-        }
-        ECFieldFp primeField = (ECFieldFp) curve.getField();
-
-        BigInteger three = BigInteger.valueOf(3);
-        if (!primeField.getP().subtract(curve.getA()).equals(three)) {
-            return Optional.empty();
-        }
-        IntegerFieldModuloP field = fields.get(primeField.getP());
-        if (field == null) {
-            return Optional.empty();
-        }
-
-        IntegerFieldModuloP orderField = orderFields.get(params.getOrder());
-        if (orderField == null) {
-            return Optional.empty();
-        }
-
-        ImmutableIntegerModuloP b = field.getElement(curve.getB());
-        ECOperations ecOps = new ECOperations(b, orderField);
-        return Optional.of(ecOps);
-    }
-
-    final ImmutableIntegerModuloP b;
-    final SmallValue one;
-    final SmallValue two;
-    final SmallValue three;
-    final SmallValue four;
-    final ProjectivePoint.Immutable neutral;
-    private final IntegerFieldModuloP orderField;
-
-    public ECOperations(IntegerModuloP b, IntegerFieldModuloP orderField) {
-        this.b = b.fixed();
-        this.orderField = orderField;
-
-        this.one = b.getField().getSmallValue(1);
-        this.two = b.getField().getSmallValue(2);
-        this.three = b.getField().getSmallValue(3);
-        this.four = b.getField().getSmallValue(4);
-
-        IntegerFieldModuloP field = b.getField();
-        this.neutral = new ProjectivePoint.Immutable(field.get0(),
-            field.get1(), field.get0());
-    }
-
-    public IntegerFieldModuloP getField() {
-        return b.getField();
-    }
-    public IntegerFieldModuloP getOrderField() {
-        return orderField;
-    }
-
-    protected ProjectivePoint.Immutable getNeutral() {
-        return neutral;
-    }
-
-    public boolean isNeutral(Point p) {
-        ProjectivePoint<?> pp = (ProjectivePoint<?>) p;
-
-        IntegerModuloP z = pp.getZ();
-
-        IntegerFieldModuloP field = z.getField();
-        int byteLength = (field.getSize().bitLength() + 7) / 8;
-        byte[] zBytes = z.asByteArray(byteLength);
-        return allZero(zBytes);
-    }
-
-    byte[] seedToScalar(byte[] seedBytes)
-        throws IntermediateValueException {
-
-        // Produce a nonce from the seed using FIPS 186-4,section B.5.1:
-        // Per-Message Secret Number Generation Using Extra Random Bits
-        // or
-        // Produce a scalar from the seed using FIPS 186-4, section B.4.1:
-        // Key Pair Generation Using Extra Random Bits
-
-        // To keep the implementation simple, sample in the range [0,n)
-        // and throw IntermediateValueException in the (unlikely) event
-        // that the result is 0.
-
-        // Get 64 extra bits and reduce in to the nonce
-        int seedBits = orderField.getSize().bitLength() + 64;
-        if (seedBytes.length * 8 < seedBits) {
-            throw new ProviderException("Incorrect seed length: " +
-            seedBytes.length * 8 + " < " + seedBits);
-        }
-
-        // input conversion only works on byte boundaries
-        // clear high-order bits of last byte so they don't influence nonce
-        int lastByteBits = seedBits % 8;
-        if (lastByteBits != 0) {
-            int lastByteIndex = seedBits / 8;
-            byte mask = (byte) (0xFF >>> (8 - lastByteBits));
-            seedBytes[lastByteIndex] &= mask;
-        }
-
-        int seedLength = (seedBits + 7) / 8;
-        IntegerModuloP scalarElem =
-            orderField.getElement(seedBytes, 0, seedLength, (byte) 0);
-        int scalarLength = (orderField.getSize().bitLength() + 7) / 8;
-        byte[] scalarArr = new byte[scalarLength];
-        scalarElem.asByteArray(scalarArr);
-        if (ECOperations.allZero(scalarArr)) {
-            throw new IntermediateValueException();
-        }
-        return scalarArr;
-    }
-
-    /*
-     * Compare all values in the array to 0 without branching on any value
-     *
-     */
-    public static boolean allZero(byte[] arr) {
-        byte acc = 0;
-        for (int i = 0; i < arr.length; i++) {
-            acc |= arr[i];
-        }
-        return acc == 0;
-    }
-
-    /*
-     * 4-bit branchless array lookup for projective points.
-     */
-    private void lookup4(ProjectivePoint.Immutable[] arr, int index,
-        ProjectivePoint.Mutable result, IntegerModuloP zero) {
-
-        for (int i = 0; i < 16; i++) {
-            int xor = index ^ i;
-            int bit3 = (xor & 0x8) >>> 3;
-            int bit2 = (xor & 0x4) >>> 2;
-            int bit1 = (xor & 0x2) >>> 1;
-            int bit0 = (xor & 0x1);
-            int inverse = bit0 | bit1 | bit2 | bit3;
-            int set = 1 - inverse;
-
-            ProjectivePoint.Immutable pi = arr[i];
-            result.conditionalSet(pi, set);
-        }
-    }
-
-    private void double4(ProjectivePoint.Mutable p, MutableIntegerModuloP t0,
-        MutableIntegerModuloP t1, MutableIntegerModuloP t2,
-        MutableIntegerModuloP t3, MutableIntegerModuloP t4) {
-
-        for (int i = 0; i < 4; i++) {
-            setDouble(p, t0, t1, t2, t3, t4);
-        }
-    }
-
-    /**
-     * Multiply an affine point by a scalar and return the result as a mutable
-     * point.
-     *
-     * @param affineP the point
-     * @param s the scalar as a little-endian array
-     * @return the product
-     */
-    public MutablePoint multiply(AffinePoint affineP, byte[] s) {
-
-        // 4-bit windowed multiply with branchless lookup.
-        // The mixed addition is faster, so it is used to construct the array
-        // at the beginning of the operation.
-
-        IntegerFieldModuloP field = affineP.getX().getField();
-        ImmutableIntegerModuloP zero = field.get0();
-        // temporaries
-        MutableIntegerModuloP t0 = zero.mutable();
-        MutableIntegerModuloP t1 = zero.mutable();
-        MutableIntegerModuloP t2 = zero.mutable();
-        MutableIntegerModuloP t3 = zero.mutable();
-        MutableIntegerModuloP t4 = zero.mutable();
-
-        ProjectivePoint.Mutable result = new ProjectivePoint.Mutable(field);
-        result.getY().setValue(field.get1().mutable());
-
-        ProjectivePoint.Immutable[] pointMultiples =
-            new ProjectivePoint.Immutable[16];
-        // 0P is neutral---same as initial result value
-        pointMultiples[0] = result.fixed();
-
-        ProjectivePoint.Mutable ps = new ProjectivePoint.Mutable(field);
-        ps.setValue(affineP);
-        // 1P = P
-        pointMultiples[1] = ps.fixed();
-
-        // the rest are calculated using mixed point addition
-        for (int i = 2; i < 16; i++) {
-            setSum(ps, affineP, t0, t1, t2, t3, t4);
-            pointMultiples[i] = ps.fixed();
-        }
-
-        ProjectivePoint.Mutable lookupResult = ps.mutable();
-
-        for (int i = s.length - 1; i >= 0; i--) {
-
-            double4(result, t0, t1, t2, t3, t4);
-
-            int high = (0xFF & s[i]) >>> 4;
-            lookup4(pointMultiples, high, lookupResult, zero);
-            setSum(result, lookupResult, t0, t1, t2, t3, t4);
-
-            double4(result, t0, t1, t2, t3, t4);
-
-            int low = 0xF & s[i];
-            lookup4(pointMultiples, low, lookupResult, zero);
-            setSum(result, lookupResult, t0, t1, t2, t3, t4);
-        }
-
-        return result;
-
-    }
-
-    /*
-     * Point double
-     */
-    private void setDouble(ProjectivePoint.Mutable p, MutableIntegerModuloP t0,
-        MutableIntegerModuloP t1, MutableIntegerModuloP t2,
-        MutableIntegerModuloP t3, MutableIntegerModuloP t4) {
-
-        t0.setValue(p.getX()).setSquare();
-        t1.setValue(p.getY()).setSquare();
-        t2.setValue(p.getZ()).setSquare();
-        t3.setValue(p.getX()).setProduct(p.getY());
-        t4.setValue(p.getY()).setProduct(p.getZ());
-
-        t3.setSum(t3);
-        p.getZ().setProduct(p.getX());
-
-        p.getZ().setProduct(two);
-
-        p.getY().setValue(t2).setProduct(b);
-        p.getY().setDifference(p.getZ());
-
-        p.getX().setValue(p.getY()).setProduct(two);
-        p.getY().setSum(p.getX());
-        p.getY().setReduced();
-        p.getX().setValue(t1).setDifference(p.getY());
-
-        p.getY().setSum(t1);
-        p.getY().setProduct(p.getX());
-        p.getX().setProduct(t3);
-
-        t3.setValue(t2).setProduct(two);
-        t2.setSum(t3);
-        p.getZ().setProduct(b);
-
-        t2.setReduced();
-        p.getZ().setDifference(t2);
-        p.getZ().setDifference(t0);
-        t3.setValue(p.getZ()).setProduct(two);
-        p.getZ().setReduced();
-        p.getZ().setSum(t3);
-        t0.setProduct(three);
-
-        t0.setDifference(t2);
-        t0.setProduct(p.getZ());
-        p.getY().setSum(t0);
-
-        t4.setSum(t4);
-        p.getZ().setProduct(t4);
-
-        p.getX().setDifference(p.getZ());
-        p.getZ().setValue(t4).setProduct(t1);
-
-        p.getZ().setProduct(four);
-
-    }
-
-    /*
-     * Mixed point addition. This method constructs new temporaries each time
-     * it is called. For better efficiency, the method that reuses temporaries
-     * should be used if more than one sum will be computed.
-     */
-    public void setSum(MutablePoint p, AffinePoint p2) {
-
-        IntegerModuloP zero = p.getField().get0();
-        MutableIntegerModuloP t0 = zero.mutable();
-        MutableIntegerModuloP t1 = zero.mutable();
-        MutableIntegerModuloP t2 = zero.mutable();
-        MutableIntegerModuloP t3 = zero.mutable();
-        MutableIntegerModuloP t4 = zero.mutable();
-        setSum((ProjectivePoint.Mutable) p, p2, t0, t1, t2, t3, t4);
-
-    }
-
-    /*
-     * Mixed point addition
-     */
-    private void setSum(ProjectivePoint.Mutable p, AffinePoint p2,
-        MutableIntegerModuloP t0, MutableIntegerModuloP t1,
-        MutableIntegerModuloP t2, MutableIntegerModuloP t3,
-        MutableIntegerModuloP t4) {
-
-        t0.setValue(p.getX()).setProduct(p2.getX());
-        t1.setValue(p.getY()).setProduct(p2.getY());
-        t3.setValue(p2.getX()).setSum(p2.getY());
-        t4.setValue(p.getX()).setSum(p.getY());
-        p.getX().setReduced();
-        t3.setProduct(t4);
-        t4.setValue(t0).setSum(t1);
-
-        t3.setDifference(t4);
-        t4.setValue(p2.getY()).setProduct(p.getZ());
-        t4.setSum(p.getY());
-
-        p.getY().setValue(p2.getX()).setProduct(p.getZ());
-        p.getY().setSum(p.getX());
-        t2.setValue(p.getZ());
-        p.getZ().setProduct(b);
-
-        p.getX().setValue(p.getY()).setDifference(p.getZ());
-        p.getX().setReduced();
-        p.getZ().setValue(p.getX()).setProduct(two);
-        p.getX().setSum(p.getZ());
-
-        p.getZ().setValue(t1).setDifference(p.getX());
-        p.getX().setSum(t1);
-        p.getY().setProduct(b);
-
-        t1.setValue(t2).setProduct(two);
-        t2.setSum(t1);
-        t2.setReduced();
-        p.getY().setDifference(t2);
-
-        p.getY().setDifference(t0);
-        p.getY().setReduced();
-        t1.setValue(p.getY()).setProduct(two);
-        p.getY().setSum(t1);
-
-        t1.setValue(t0).setProduct(two);
-        t0.setSum(t1);
-        t0.setDifference(t2);
-
-        t1.setValue(t4).setProduct(p.getY());
-        t2.setValue(t0).setProduct(p.getY());
-        p.getY().setValue(p.getX()).setProduct(p.getZ());
-
-        p.getY().setSum(t2);
-        p.getX().setProduct(t3);
-        p.getX().setDifference(t1);
-
-        p.getZ().setProduct(t4);
-        t1.setValue(t3).setProduct(t0);
-        p.getZ().setSum(t1);
-
-    }
-
-    /*
-     * Projective point addition
-     */
-    private void setSum(ProjectivePoint.Mutable p, ProjectivePoint.Mutable p2,
-        MutableIntegerModuloP t0, MutableIntegerModuloP t1,
-        MutableIntegerModuloP t2, MutableIntegerModuloP t3,
-        MutableIntegerModuloP t4) {
-
-        t0.setValue(p.getX()).setProduct(p2.getX());
-        t1.setValue(p.getY()).setProduct(p2.getY());
-        t2.setValue(p.getZ()).setProduct(p2.getZ());
-
-        t3.setValue(p.getX()).setSum(p.getY());
-        t4.setValue(p2.getX()).setSum(p2.getY());
-        t3.setProduct(t4);
-
-        t4.setValue(t0).setSum(t1);
-        t3.setDifference(t4);
-        t4.setValue(p.getY()).setSum(p.getZ());
-
-        p.getY().setValue(p2.getY()).setSum(p2.getZ());
-        t4.setProduct(p.getY());
-        p.getY().setValue(t1).setSum(t2);
-
-        t4.setDifference(p.getY());
-        p.getX().setSum(p.getZ());
-        p.getY().setValue(p2.getX()).setSum(p2.getZ());
-
-        p.getX().setProduct(p.getY());
-        p.getY().setValue(t0).setSum(t2);
-        p.getY().setAdditiveInverse().setSum(p.getX());
-        p.getY().setReduced();
-
-        p.getZ().setValue(t2).setProduct(b);
-        p.getX().setValue(p.getY()).setDifference(p.getZ());
-        p.getZ().setValue(p.getX()).setProduct(two);
-
-        p.getX().setSum(p.getZ());
-        p.getX().setReduced();
-        p.getZ().setValue(t1).setDifference(p.getX());
-        p.getX().setSum(t1);
-
-        p.getY().setProduct(b);
-        t1.setValue(t2).setSum(t2);
-        t2.setSum(t1);
-        t2.setReduced();
-
-        p.getY().setDifference(t2);
-        p.getY().setDifference(t0);
-        p.getY().setReduced();
-        t1.setValue(p.getY()).setSum(p.getY());
-
-        p.getY().setSum(t1);
-        t1.setValue(t0).setProduct(two);
-        t0.setSum(t1);
-
-        t0.setDifference(t2);
-        t1.setValue(t4).setProduct(p.getY());
-        t2.setValue(t0).setProduct(p.getY());
-
-        p.getY().setValue(p.getX()).setProduct(p.getZ());
-        p.getY().setSum(t2);
-        p.getX().setProduct(t3);
-
-        p.getX().setDifference(t1);
-        p.getZ().setProduct(t4);
-        t1.setValue(t3).setProduct(t0);
-
-        p.getZ().setSum(t1);
-
-    }
-}
--- openjdk.orig/jdk/src/share/classes/sun/security/ec/point/AffinePoint.java	2019-07-14 02:30:40.000000000 +0200
+++ openjdk/jdk/src/share/classes/sun/security/ec/point/AffinePoint.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-/*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.security.ec.point;
-
-import sun.security.util.math.ImmutableIntegerModuloP;
-
-import java.util.Objects;
-
-/**
- * Elliptic curve point represented using affine coordinates (x, y). This class
- * is not part of the sun.security.ec.point.Point hierarchy because it is not
- * used to hold intermediate values during point arithmetic, and so it does not
- * have a mutable form.
- */
-public class AffinePoint {
-
-    private final ImmutableIntegerModuloP x;
-    private final ImmutableIntegerModuloP y;
-
-    public AffinePoint(ImmutableIntegerModuloP x, ImmutableIntegerModuloP y) {
-        this.x = x;
-        this.y = y;
-    }
-
-    public ImmutableIntegerModuloP getX() {
-        return x;
-    }
-
-    public ImmutableIntegerModuloP getY() {
-        return y;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (!(obj instanceof AffinePoint)) {
-            return false;
-        }
-        AffinePoint p = (AffinePoint) obj;
-        boolean xEquals = x.asBigInteger().equals(p.x.asBigInteger());
-        boolean yEquals = y.asBigInteger().equals(p.y.asBigInteger());
-        return xEquals && yEquals;
-    }
-
-    @Override
-    public int hashCode() {
-        return Objects.hash(x, y);
-    }
-
-    @Override
-    public String toString() {
-        return "(" + x.asBigInteger().toString() + "," +
-            y.asBigInteger().toString() + ")";
-    }
-}
--- openjdk.orig/jdk/src/share/classes/sun/security/ec/point/ImmutablePoint.java	2019-07-14 02:30:40.000000000 +0200
+++ openjdk/jdk/src/share/classes/sun/security/ec/point/ImmutablePoint.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-/*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.security.ec.point;
-
-/**
- * An interface for immutable points on an elliptic curve over a finite field.
- */
-public interface ImmutablePoint extends Point {
-}
--- openjdk.orig/jdk/src/share/classes/sun/security/ec/point/MutablePoint.java	2019-07-14 02:30:40.000000000 +0200
+++ openjdk/jdk/src/share/classes/sun/security/ec/point/MutablePoint.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-/*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.security.ec.point;
-
-/**
- * An interface for mutable points on an elliptic curve over a finite field.
- */
-public interface MutablePoint extends Point {
-
-    MutablePoint setValue(AffinePoint p);
-    MutablePoint setValue(Point p);
-    MutablePoint conditionalSet(Point p, int set);
-
-}
--- openjdk.orig/jdk/src/share/classes/sun/security/ec/point/Point.java	2019-07-14 02:30:40.000000000 +0200
+++ openjdk/jdk/src/share/classes/sun/security/ec/point/Point.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.security.ec.point;
-
-import sun.security.util.math.IntegerFieldModuloP;
-
-/**
- * A base interface for points on an elliptic curve over a finite field.
- * Implementations may use different representations for points, and this
- * interface creates a common API for manipulating points. This API has no
- * methods for point arithmetic, which depends on group structure and curve
- * parameters in addition to point representation.
- */
-public interface Point {
-
-    IntegerFieldModuloP getField();
-    AffinePoint asAffine();
-
-    ImmutablePoint fixed();
-    MutablePoint mutable();
-
-}
--- openjdk.orig/jdk/src/share/classes/sun/security/ec/point/ProjectivePoint.java	2019-07-14 02:30:40.000000000 +0200
+++ openjdk/jdk/src/share/classes/sun/security/ec/point/ProjectivePoint.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,160 +0,0 @@
-/*
- * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.security.ec.point;
-
-import sun.security.util.math.*;
-
-/**
- * Elliptic curve point in projective coordinates (X, Y, Z) where
- * an affine point (x, y) is represented using any (X, Y, Z) s.t.
- * x = X/Z and y = Y/Z.
- */
-public abstract class ProjectivePoint
-    <T extends IntegerModuloP> implements Point {
-
-    protected final T x;
-    protected final T y;
-    protected final T z;
-
-    protected ProjectivePoint(T x, T y, T z) {
-
-        this.x = x;
-        this.y = y;
-        this.z = z;
-    }
-
-    @Override
-    public IntegerFieldModuloP getField() {
-        return this.x.getField();
-    }
-
-    @Override
-    public Immutable fixed() {
-        return new Immutable(x.fixed(), y.fixed(), z.fixed());
-    }
-
-    @Override
-    public Mutable mutable() {
-        return new Mutable(x.mutable(), y.mutable(), z.mutable());
-    }
-
-    public T getX() {
-        return x;
-    }
-
-    public T getY() {
-        return y;
-    }
-
-    public T getZ() {
-        return z;
-    }
-
-    public AffinePoint asAffine() {
-        IntegerModuloP zInv = z.multiplicativeInverse();
-        return new AffinePoint(x.multiply(zInv), y.multiply(zInv));
-    }
-
-    public static class Immutable
-        extends ProjectivePoint<ImmutableIntegerModuloP>
-        implements ImmutablePoint {
-
-        public Immutable(ImmutableIntegerModuloP x,
-                         ImmutableIntegerModuloP y,
-                         ImmutableIntegerModuloP z) {
-            super(x, y, z);
-        }
-    }
-
-    public static class Mutable
-        extends ProjectivePoint<MutableIntegerModuloP>
-        implements MutablePoint {
-
-        public Mutable(MutableIntegerModuloP x,
-                       MutableIntegerModuloP y,
-                       MutableIntegerModuloP z) {
-            super(x, y, z);
-        }
-
-        public Mutable(IntegerFieldModuloP field) {
-            super(field.get0().mutable(),
-                field.get0().mutable(),
-                field.get0().mutable());
-        }
-
-        @Override
-        public Mutable conditionalSet(Point p, int set) {
-            if (!(p instanceof ProjectivePoint)) {
-                throw new RuntimeException("Incompatible point");
-            }
-            @SuppressWarnings("unchecked")
-            ProjectivePoint<IntegerModuloP> pp =
-                (ProjectivePoint<IntegerModuloP>) p;
-            return conditionalSet(pp, set);
-        }
-
-        private <T extends IntegerModuloP>
-        Mutable conditionalSet(ProjectivePoint<T> pp, int set) {
-
-            x.conditionalSet(pp.x, set);
-            y.conditionalSet(pp.y, set);
-            z.conditionalSet(pp.z, set);
-
-            return this;
-        }
-
-        @Override
-        public Mutable setValue(AffinePoint p) {
-            x.setValue(p.getX());
-            y.setValue(p.getY());
-            z.setValue(p.getX().getField().get1());
-
-            return this;
-        }
-
-        @Override
-        public Mutable setValue(Point p) {
-            if (!(p instanceof ProjectivePoint)) {
-                throw new RuntimeException("Incompatible point");
-            }
-            @SuppressWarnings("unchecked")
-            ProjectivePoint<IntegerModuloP> pp =
-                (ProjectivePoint<IntegerModuloP>) p;
-            return setValue(pp);
-        }
-
-        private <T extends IntegerModuloP>
-        Mutable setValue(ProjectivePoint<T> pp) {
-
-            x.setValue(pp.x);
-            y.setValue(pp.y);
-            z.setValue(pp.z);
-
-            return this;
-        }
-
-    }
-
-}
--- openjdk.orig/jdk/src/share/classes/sun/security/util/Function.java	2019-07-14 02:30:40.000000000 +0200
+++ openjdk/jdk/src/share/classes/sun/security/util/Function.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-/*
- * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.security.util;
-
-/**
- * Represents a function that accepts one argument and produces a result.
- *
- * @param <T> the type of the input to the function
- * @param <R> the type of the result of the function
- *
- * @since 1.8
- */
-public interface Function<T, R> {
-
-    /**
-     * Applies this function to the given argument.
-     *
-     * @param t the function argument
-     * @return the function result
-     */
-    R apply(T t);
-}
--- openjdk.orig/jdk/src/share/classes/sun/security/util/Optional.java	2019-07-14 02:30:40.000000000 +0200
+++ openjdk/jdk/src/share/classes/sun/security/util/Optional.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,271 +0,0 @@
-/*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.security.util;
-
-import java.util.Objects;
-import java.util.NoSuchElementException;
-
-/**
- * A container object which may or may not contain a non-null value.
- * If a value is present, {@code isPresent()} will return {@code true} and
- * {@code get()} will return the value.
- *
- * <p>Additional methods that depend on the presence or absence of a contained
- * value are provided, such as {@link #orElse(java.lang.Object) orElse()}
- * (return a default value if value not present) and
- * {@link #ifPresent(java.util.function.Consumer) ifPresent()} (execute a block
- * of code if the value is present).
- *
- * <p>This is a <a href="../lang/doc-files/ValueBased.html">value-based</a>
- * class; use of identity-sensitive operations (including reference equality
- * ({@code ==}), identity hash code, or synchronization) on instances of
- * {@code Optional} may have unpredictable results and should be avoided.
- *
- * @since 1.8
- */
-public final class Optional<T> {
-    /**
-     * Common instance for {@code empty()}.
-     */
-    private static final Optional<?> EMPTY = new Optional<>();
-
-    /**
-     * If non-null, the value; if null, indicates no value is present
-     */
-    private final T value;
-
-    /**
-     * Constructs an empty instance.
-     *
-     * @implNote Generally only one empty instance, {@link Optional#EMPTY},
-     * should exist per VM.
-     */
-    private Optional() {
-        this.value = null;
-    }
-
-    /**
-     * Returns an empty {@code Optional} instance.  No value is present for this
-     * {@code Optional}.
-     *
-     * @apiNote
-     * Though it may be tempting to do so, avoid testing if an object is empty
-     * by comparing with {@code ==} against instances returned by
-     * {@code Optional.empty()}.  There is no guarantee that it is a singleton.
-     * Instead, use {@link #isPresent()}.
-     *
-     * @param <T> The type of the non-existent value
-     * @return an empty {@code Optional}
-     */
-    public static<T> Optional<T> empty() {
-        @SuppressWarnings("unchecked")
-        Optional<T> t = (Optional<T>) EMPTY;
-        return t;
-    }
-
-
-    /**
-     * Constructs an instance with the described value.
-     *
-     * @param value the non-{@code null} value to describe
-     * @throws NullPointerException if value is {@code null}
-     */
-    private Optional(T value) {
-        this.value = Objects.requireNonNull(value);
-    }
-
-    /**
-     * Returns an {@code Optional} describing the given non-{@code null}
-     * value.
-     *
-     * @param value the value to describe, which must be non-{@code null}
-     * @param <T> the type of the value
-     * @return an {@code Optional} with the value present
-     * @throws NullPointerException if value is {@code null}
-     */
-    public static <T> Optional<T> of(T value) {
-        return new Optional<>(value);
-    }
-
-    /**
-     * Returns an {@code Optional} describing the specified value, if non-null,
-     * otherwise returns an empty {@code Optional}.
-     *
-     * @param <T> the class of the value
-     * @param value the possibly-null value to describe
-     * @return an {@code Optional} with a present value if the specified value
-     * is non-null, otherwise an empty {@code Optional}
-     */
-    public static <T> Optional<T> ofNullable(T value) {
-        return value == null ? new Optional<T>() : of(value);
-    }
-
-    /**
-     * If a value is present, returns the value, otherwise throws
-     * {@code NoSuchElementException}.
-     *
-     * @apiNote
-     * The preferred alternative to this method is {@link #orElseThrow()}.
-     *
-     * @return the non-{@code null} value described by this {@code Optional}
-     * @throws NoSuchElementException if no value is present
-     */
-    public T get() {
-        if (value == null) {
-            throw new NoSuchElementException("No value present");
-        }
-        return value;
-    }
-
-    /**
-     * If a value is present, returns {@code true}, otherwise {@code false}.
-     *
-     * @return {@code true} if a value is present, otherwise {@code false}
-     */
-    public boolean isPresent() {
-        return value != null;
-    }
-
-    /**
-     * If a value is  not present, returns {@code true}, otherwise
-     * {@code false}.
-     *
-     * @return  {@code true} if a value is not present, otherwise {@code false}
-     * @since   11
-     */
-    public boolean isEmpty() {
-        return value == null;
-    }
-
-    /**
-     * If a value is present, apply the provided mapping function to it,
-     * and if the result is non-null, return an {@code Optional} describing the
-     * result.  Otherwise return an empty {@code Optional}.
-     *
-     * @apiNote This method supports post-processing on optional values, without
-     * the need to explicitly check for a return status.  For example, the
-     * following code traverses a stream of file names, selects one that has
-     * not yet been processed, and then opens that file, returning an
-     * {@code Optional<FileInputStream>}:
-     *
-     * <pre>{@code
-     *     Optional<FileInputStream> fis =
-     *         names.stream().filter(name -> !isProcessedYet(name))
-     *                       .findFirst()
-     *                       .map(name -> new FileInputStream(name));
-     * }</pre>
-     *
-     * Here, {@code findFirst} returns an {@code Optional<String>}, and then
-     * {@code map} returns an {@code Optional<FileInputStream>} for the desired
-     * file if one exists.
-     *
-     * @param <U> The type of the result of the mapping function
-     * @param mapper a mapping function to apply to the value, if present
-     * @return an {@code Optional} describing the result of applying a mapping
-     * function to the value of this {@code Optional}, if a value is present,
-     * otherwise an empty {@code Optional}
-     * @throws NullPointerException if the mapping function is null
-     */
-    public<U> Optional<U> map(Function<? super T, ? extends U> mapper) {
-        Objects.requireNonNull(mapper);
-        if (!isPresent())
-            return empty();
-        else {
-            return Optional.ofNullable(mapper.apply(value));
-        }
-    }
-
-    /**
-     * Return the value if present, otherwise invoke {@code other} and return
-     * the result of that invocation.
-     *
-     * @param other a {@code Supplier} whose result is returned if no value
-     * is present
-     * @return the value if present otherwise the result of {@code other.get()}
-     * @throws NullPointerException if value is not present and {@code other} is
-     * null
-     */
-    public T orElseGet(Supplier<? extends T> other) {
-        return value != null ? value : other.get();
-    }
-
-    /**
-     * Indicates whether some other object is "equal to" this {@code Optional}.
-     * The other object is considered equal if:
-     * <ul>
-     * <li>it is also an {@code Optional} and;
-     * <li>both instances have no value present or;
-     * <li>the present values are "equal to" each other via {@code equals()}.
-     * </ul>
-     *
-     * @param obj an object to be tested for equality
-     * @return {@code true} if the other object is "equal to" this object
-     *         otherwise {@code false}
-     */
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-
-        if (!(obj instanceof Optional)) {
-            return false;
-        }
-
-        Optional<?> other = (Optional<?>) obj;
-        return Objects.equals(value, other.value);
-    }
-
-    /**
-     * Returns the hash code of the value, if present, otherwise {@code 0}
-     * (zero) if no value is present.
-     *
-     * @return hash code value of the present value or {@code 0} if no value is
-     *         present
-     */
-    @Override
-    public int hashCode() {
-        return Objects.hashCode(value);
-    }
-
-    /**
-     * Returns a non-empty string representation of this {@code Optional}
-     * suitable for debugging.  The exact presentation format is unspecified and
-     * may vary between implementations and versions.
-     *
-     * @implSpec
-     * If a value is present the result must include its string representation
-     * in the result.  Empty and present {@code Optional}s must be unambiguously
-     * differentiable.
-     *
-     * @return the string representation of this instance
-     */
-    @Override
-    public String toString() {
-        return value != null
-            ? String.format("Optional[%s]", value)
-            : "Optional.empty";
-    }
-}
--- openjdk.orig/jdk/src/share/classes/sun/security/util/Supplier.java	2019-07-14 02:30:40.000000000 +0200
+++ openjdk/jdk/src/share/classes/sun/security/util/Supplier.java	1970-01-01 01:00:00.000000000 +0100
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package sun.security.util;
-
-/**
- * Represents a supplier of results.
- *
- * <p>There is no requirement that a new or distinct result be returned each
- * time the supplier is invoked.
- *
- * <p>This is a <a href="package-summary.html">functional interface</a>
- * whose functional method is {@link #get()}.
- *
- * @param <T> the type of results supplied by this supplier
- *
- * @since 1.8
- */
-public interface Supplier<T> {
-
-    /**
-     * Gets a result.
-     *
-     * @return a result
-     */
-    T get();
-}
